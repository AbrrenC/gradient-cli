"""
Jobs related client handler logic.

Remember that in code snippets all highlighted lines are required other are optional
"""
from gradient.config import config
from .base_client import BaseClient
from ..clients import http_client
from ..models import Job
from ..serializers import JobSchema
from ..repositories.jobs import ListJobs, ListJobLogs, ListJobArtifacts
from ..utils import MessageExtractor


class JobsClient(BaseClient):
    """
    Client to handle job related actions.

    How to create instance of job client:

    .. code-block:: python
        :linenos:
        :emphasize-lines: 4

        from gradient import JobsClient

        job_client = JobClient(
            api_key='your_api_key_here'
        )

    """
    HOST_URL = config.CONFIG_HOST

    def __init__(self, *args, **kwargs):
        super(JobsClient, self).__init__(*args, **kwargs)
        self.logs_client = http_client.API(config.CONFIG_LOG_HOST,
                                           api_key=self.api_key,
                                           logger=self.logger)

    def create(
            self,
            machine_type,
            container,
            project_id,
            data,
            name=None,
            command=None,
            ports=None,
            is_public=None,
            workspace=None,
            workspace_archive=None,
            workspace_url=None,
            working_directory=None,
            ignore_files=None,
            experiment_id=None,
            job_env=None,
            use_dockerfile=None,
            is_preemptible=None,
            project=None,
            started_by_user_id=None,
            rel_dockerfile_path=None,
            registry_username=None,
            registry_password=None,
            cluster=None,
            cluster_id=None,
            node_attrs=None,
            workspace_file_name=None,
    ):
        """
        Method to create and start job in paperspace gradient.

        Example create job:

        .. code-block:: python
            :linenos:
            :emphasize-lines: 2,3,4,5

            job = job_client.create(
                machine_type='K80',
                container='tensorflow/tensorflow:1.13.1-gpu-py3',
                project_id='Som3ProjecTiD',
                data=data,
                name='Example job',
                command='pip install -r requirements.txt && python mnist.py',
                ports='5000:5000',
                workspace_url='git+https://github.com/Paperspace/mnist-sample.git',
                job_env={
                    'CUSTOM_ENV'='Some value that will be set as system environment',
                }
            )

        :param str machine_type: Type of machine on which job should run. This field is **required**.

            Choose one of this:

            .. code-block::

                K80
                P100
                TPU
                GV100
                GV100x8
                G1
                G6
                G12

        :param str container: name of docker container that should be used to run job. This field is **required**.

            Example value: ``tensorflow/tensorflow:1.13.1-gpu-py3``

        :param str project_id: Identify to which project job should be connected. This field is **required**.

        :param None|MultipartEncoderMonitor data: None if there are no data to upload or
            encoded multipart data information with files to upload.
        :param str name: name for job that creator wish to have. If not provided it will be autogenerated.
        :param str command: custom command that should be run against command from docker image
        :param str ports: string with coma `,` separated mapped ports.

            Example value: ``5000:5000,8080:8080``

        :param bool is_public: bool flag to select if job should be available by default None
        :param str workspace: this field is used with CLI to upload folder as your workspace. You can provide here path
            that you wish to upload. (Soon also will support a path to a workspace archive or git repository URL.)
        :param str workspace_archive: Path to workspace archive. (Currently being deprecated in an upcoming version.)
        :param str workspace_url: url to repo with code to run inside of job.
            (Currently being deprecated in an upcoming version.)
        :param str working_directory: location of code to run. By default ``/paperspace``
        :param str ignore_files: This field is used with CLI to upload workspace from your computer without specified
            files. Provide string with `,` separated name of files that should be ignored with upload of workspace.
        :param str experiment_id: Id of experiment to which job should be connected. If not provided there will be
            created new experiment for this job.
        :param dict job_env: key value collection of envs that are used in code
        :param bool use_dockerfile: determines whether to build from Dockerfile (default false).
            Do not include a --container argument when using this flag.
        :param bool is_preemptible: flag if we you want to use spot instance. By default False
        :param str project: name of project that job is linked to.
        :param str started_by_user_id: id of user that started job. By default it take user id from access token
            or api key.
        :param str rel_dockerfile_path: relative location to your dockerfile. Default set to ``./Dockerfile``
        :param str registry_username: username for custom docker registry
        :param str registry_password: password for custom docker registry
        :param str cluster: name of cluster that job should be run on.
        :param str cluster_id: id of cluster that job should be run on. If you use one of recommended machine type
            cluster will be chosen so you do not need to provide it.
        :param dict node_attrs:
        :param str workspace_file_name:

        :returns: json with response after job creation request
        :rtype: dict
        """
        job = Job(
            machine_type=machine_type,
            container=container,
            project_id=project_id,
            name=name,
            command=command,
            ports=ports,
            is_public=is_public,
            workspace=workspace,
            workspace_archive=workspace_archive,
            workspace_url=workspace_url,
            working_directory=working_directory,
            ignore_files=ignore_files,
            experiment_id=experiment_id,
            job_env=job_env,
            use_dockerfile=use_dockerfile,
            is_preemptible=is_preemptible,
            project=project,
            started_by_user_id=started_by_user_id,
            rel_dockerfile_path=rel_dockerfile_path,
            registry_username=registry_username,
            registry_password=registry_password,
            cluster=cluster,
            cluster_id=cluster_id,
            target_node_attrs=node_attrs,
            workspace_file_name=workspace_file_name,
        )
        job_dict = JobSchema().dump(job).data
        return self._create(job_dict, data)

    def delete(self, job_id):
        """
        Method to remove job.

        .. code-block:: python
            :linenos:
            :emphasize-lines: 2

            job = job_client.delete(
                job_id='Your_job_id_here'
            )

        :param str job_id: id of job that you want to remove
        :returns: json response after delete was complete
        :rtype: dict
        """
        url = self._get_action_url(job_id, "destroy")
        response = self.client.post(url)
        return response

    def stop(self, job_id):
        """
        Method to stop working job

        .. code-block:: python
            :linenos:
            :emphasize-lines: 2

            job = job_client.stop(
                job_id='Your_job_id_here'
            )

        :param job_id: id of job that we want to stop
        :returns: json response after stop was complete
        :rtype: dict
        """
        url = self._get_action_url(job_id, "stop")
        response = self.client.post(url)
        return response

    def list(self, filters):
        """
        Method to list jobs.

        To retrieve all user jobs:

        .. code-block:: python
            :linenos:

            jobs = job_client.list()

        To list jobs from project:

        .. code-block:: python
            :linenos:

            filters = {
                "filters": {
                    "projectId": "Your_project_id_here",
                }
            }

            job = job_client.list(
                filters=filters
            )

        Possible options to use in filters:
            - projectId
            - project
            - experimentId

        :param dict filters: dict of filters that will be used to retrieve jobs.

        :returns: list of jobs dicts
        :rtype: list
        """
        return ListJobs(self.client).list(filters=filters)

    def logs(self, job_id, line=0, limit=10000):
        """
        Method to retrieve job logs.

        .. code-block:: python
            :linenos:
            :emphasize-lines: 2

            job = job_client.logs(
                job_id='Your_job_id_here'
            )

        :param str job_id: id of job that we want to retrieve logs
        :param int line: from what line you want to retrieve logs. Default 0
        :param int limit: how much lines you want to retrieve logs. Default 10000

        :returns:
        :rtype:
        """
        logs = ListJobLogs(self.logs_client).list(job_id=job_id, line=line, limit=limit)
        return logs

    def artifacts_delete(self, job_id, params):
        """

        :param job_id:
        :param params:
        :return:
        """
        url = self._get_action_url(job_id, "artifactsDestroy", ending_slash=False)
        response = self.client.post(url, params=params)
        return response

    def artifacts_get(self, job_id):
        """

        :param job_id:
        :return:
        """
        url = '/jobs/artifactsGet'
        response = self.client.get(url, params={'jobId': job_id})
        return response

    def artifacts_list(self, filters):
        """

        :param filters:
        :return:
        """
        return ListJobArtifacts(self.client).list(filters=filters)

    def _create(self, job_dict, data):
        """

        :param job_dict:
        :param data:
        :return:
        """
        response = self._get_create_response(job_dict, data)
        return response

    def _get_create_response(self, json_, data):
        """

        :param json_:
        :param data:
        :return:
        """
        return self.client.post("/jobs/createJob/", params=json_, data=data)

    @staticmethod
    def _get_error_message(response):
        try:
            response_data = response.json()
        except ValueError:
            return "Unknown error"

        msg = MessageExtractor().get_message_from_response_data(response_data)
        return msg

    @staticmethod
    def _get_action_url(job_id, action, ending_slash=True):
        template_with_ending_slash = "/jobs/{}/{}/"
        template_without_ending_slash = "/jobs/{}/{}"

        if ending_slash:
            template = template_with_ending_slash
        else:
            template = template_without_ending_slash
        return template.format(job_id, action)
